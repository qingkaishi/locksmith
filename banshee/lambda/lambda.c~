/*

DO NOT edit this file

*/
#include "list.h"
#include "regions.h"
#include "banshee.h"
#include <assert.h>
#include <stdio.h>
#include "bool.h"
#include "ufind.h"
#include <string.h>
#include "hash.h"
#include "banshee_region_persist_kinds.h"
#include "term-sort.h"

#define BOOLEAN_ 11
#define INTEGER_ 12
#define FUNCTION_ 13

typedef gen_e l_type;
typedef gen_e_list l_type_list;


stamp l_type_get_stamp(gen_e arg1);
bool l_type_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(l_type_list,gen_e);
l_type l_type_zero(void);
l_type l_type_one(void);
l_type l_type_wild(void);
l_type l_type_fresh(const char *name);
l_type l_type_constant(const char *name) ;
bool l_type_is_constant(l_type e,const char *name);
l_type l_type_ecr(l_type e) ;
void l_type_inclusion_ind(l_type e1,l_type e2) ;
void l_type_cunify_ind(l_type e1, l_type e2) ;
void l_type_unify_ind(l_type e1,l_type e2) ;

static struct gen_term boolean_ = {BOOLEAN_,BOOLEAN_};
l_type boolean(void);
bool l_type_is_boolean(l_type arg1);
static struct gen_term integer_ = {INTEGER_,INTEGER_};
l_type integer(void);
bool l_type_is_integer(l_type arg1);
l_type function(l_type arg1,l_type arg2);
struct function_decon function_decon(l_type arg1);
struct function_
{
int type;
stamp st;
l_type f0;
l_type f1;
};
struct function_decon
{
l_type f0;
l_type f1;
};
void l_type_print(FILE* arg1,l_type arg2);
bool l_type_occurs(term_var arg1,l_type arg2);
void l_type_con_match(gen_e arg1,gen_e arg2);

stamp l_type_get_stamp(gen_e arg1) 
{
return term_get_stamp((gen_e)arg1);
}

bool l_type_is_var(gen_e arg1) 
{
return term_is_var((gen_e)arg1);
}

DEFINE_LIST(l_type_list,gen_e);

l_type l_type_zero(void)
{
 return term_zero();
}

l_type l_type_one(void)
{
 return term_one();
}

l_type l_type_wild(void)
{
 return term_wild();
}

l_type l_type_fresh(const char *name)
{
 return term_fresh(name);
}

l_type l_type_fresh_small(const char *name)
{
 return term_fresh_small(name);
}

l_type l_type_fresh_large(const char *name)
{
 return term_fresh_large(name);
}

l_type l_type_constant(const char *name) 
{
 return term_constant(name);
}

bool l_type_is_constant(l_type e, const char *name) 
{
 if (term_is_constant(e))
return (! strcmp(name,term_get_constant_name(e)));
else return FALSE;
}

l_type l_type_ecr(l_type e) 
{
 return term_get_ecr(e);
}

void l_type_inclusion_ind(l_type e1, l_type e2) 
{
 term_unify(l_type_con_match,l_type_occurs,e1,e2);
}

bool l_type_eq(l_type e1, l_type e2)
{
 return term_eq(e1,e2);
}

int l_type_cmp(const l_type e1,const l_type e2) 
{
 return term_get_stamp(e1) - term_get_stamp(e2);
}

void l_type_inclusion_ind_contra(l_type e1, l_type e2) 
{
 term_unify(l_type_con_match,l_type_occurs,e2,e1);
}

void l_type_unify(l_type e1, l_type e2) 
{
 banshee_clock_tick();
l_type_unify_ind(e1,e2);
}

void l_type_cunify(l_type e1, l_type e2) 
{
 banshee_clock_tick();
l_type_cunify_ind(e1,e2);
}

void l_type_cunify_ind(l_type e1, l_type e2) 
{
 term_cunify(l_type_con_match,l_type_occurs,e1,e2);
}

void l_type_unify_ind(l_type e1, l_type e2) 
{
 term_unify(l_type_con_match,l_type_occurs,e1,e2);
}

l_type boolean(void) 
{
return (gen_e)&boolean_;
}

bool l_type_is_boolean(l_type arg1) 
{
return ((gen_term)arg1)->type == boolean_.st;
}

l_type integer(void) 
{
return (gen_e)&integer_;
}

bool l_type_is_integer(l_type arg1) 
{
return ((gen_term)arg1)->type == integer_.st;
}

bool l_type_is_function(l_type e)
{
 return ((gen_term)e)->type == 13;
}

l_type function(l_type arg1,l_type arg2) 
{
struct function_ *ret;
stamp s[3];
s[0] = FUNCTION_;
s[1] = l_type_get_stamp((gen_e)arg1);
s[2] = l_type_get_stamp((gen_e)arg2);
if ((ret = (struct function_ *)term_hash_find(term_sort_hash,s,3)) == NULL)
{
ret = ralloc(term_sort_region,struct function_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
ret->f1 = arg2;
term_hash_insert(term_sort_hash,(gen_e)ret,s,3);
}
return (l_type)ret;
}

struct function_decon function_decon(l_type arg1) 
{
if (((gen_term)arg1)->type == FUNCTION_)
{
struct function_* c = (struct function_ *)arg1;
return (struct function_decon){c->f0,c->f1};

}
else 
return (struct function_decon){NULL,NULL};
}

void l_type_print(FILE* arg1,l_type arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s",tv_get_name((term_var)ecr));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1, "%s", term_get_constant_name(ecr));
break;
case BOOLEAN_:
fprintf(arg1,"boolean");
break;
case INTEGER_:
fprintf(arg1,"integer");
break;
case FUNCTION_:
{
fprintf(arg1,"function(");
l_type_print(arg1,((struct function_ *)ecr)->f0);
fprintf(arg1,",");
l_type_print(arg1,((struct function_ *)ecr)->f1);
fprintf(arg1,")");

}
break;

default:
return ;
}

}

bool l_type_occurs(term_var arg1,l_type arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
return (term_get_stamp((gen_e)arg1) == term_get_stamp(ecr));
break;
case BOOLEAN_:
return FALSE;
break;
case INTEGER_:
return FALSE;
break;
case FUNCTION_:
{
struct function_ *con = (struct function_ *)arg2;
return l_type_occurs(arg1,con->f0) || l_type_occurs(arg1,con->f1);

}
break;

default:
return FALSE;
}

}

void l_type_con_match(gen_e arg1,gen_e arg2) 
{
switch(((gen_term)arg1)->type)
{
case BOOLEAN_:
if (((gen_term)arg1)->type != ((gen_term)arg2)->type) handle_error(arg1,arg2,bek_cons_mismatch);
break;
case INTEGER_:
if (((gen_term)arg1)->type != ((gen_term)arg2)->type) handle_error(arg1,arg2,bek_cons_mismatch);
break;
case FUNCTION_:
switch(((gen_term)arg2)->type)
{
case FUNCTION_:
{
l_type_unify_ind(((struct function_ *)arg1)->f0,((struct function_ *)arg2)->f0);
l_type_unify_ind(((struct function_ *)arg1)->f1,((struct function_ *)arg2)->f1);

}
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

void lambda_init(void) 
{
engine_init();
term_init();
}

void lambda_reset(void) 
{
engine_reset();
term_reset();
}

void lambda_stats(FILE * arg1) 
{
engine_stats(arg1);
}

void lambda_print_graph(FILE * arg1) 
{
print_constraint_graphs(arg1);
}

void lambda_serialize(FILE * arg1,hash_table * arg2,unsigned long arg3) 
{
return;
}

hash_table * lambda_deserialize(FILE * arg1) 
{
return NULL;
}

void lambda_region_serialize(FILE * arg1) 
{
return;
}

void lambda_region_deserialize(translation arg1,FILE * arg2) 
{
return;
}

