/*

DO NOT edit this file

*/
#include "list.h"
#include "regions.h"
#include "banshee.h"
#include <assert.h>
#include <stdio.h>
#include "bool.h"
#include "ufind.h"
#include <string.h>
#include "hash.h"
#include "banshee_region_persist_kinds.h"
#include "setif-sort.h"

#define OPOS_ 11
#define NGROUP_ 12
#define NGROUPPROJ0_ 13
#define OPOSPROJ0_ 14
#define ONEG_ 15
#define NCONTRAGROUP_ 16
#define NCONTRAGROUPPROJ0_ 17
#define ONEGPROJ0_ 18
#define POS_ 19
#define POSPROJ0_ 20

typedef gen_e node_T;
typedef gen_e_list node_T_list;


stamp node_T_get_stamp(gen_e arg1);
bool node_T_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(node_T_list,gen_e);
node_T node_T_zero(void);
node_T node_T_one(void);
node_T node_T_wild(void);
node_T node_T_fresh(const char *name);
node_T node_T_fresh_large(const char *name);
node_T node_T_union(node_T_list exprs);
node_T node_T_inter(node_T_list exprs);
node_T node_T_constant(const char *name);
bool node_T_is_constant(node_T e,const char *name);
node_T_list node_T_tlb(node_T e);
void node_T_inclusion_ind(node_T e1,node_T e2);
void node_T_unify_ind(node_T e1,node_T e2);

struct OPos_
{
int type;
stamp st;
int index;
node_T f0;
};
struct OPos_decon
{
int index;
node_T f0;
};
struct NGroup_
{
int type;
stamp st;
node_T f0;
};
struct NGroup_decon
{
node_T f0;
};
node_T OPos(int arg1,node_T arg2);
node_T NGroup(node_T arg1);
struct OPos_decon OPos_decon(node_T arg1);
struct NGroup_decon NGroup_decon(node_T arg1);
struct NGroupProj0_
{
int type;
stamp st;
node_T f0;
};
gen_e NGroup_pat0_con(gen_e arg1);
node_T NGroup_pat0(node_T arg1);
static int OPos_index_0;
struct OPosProj0_
{
int type;
stamp st;
int index;
node_T f0;
};
gen_e OPos_pat0_con(gen_e arg1,int arg2);
node_T OPos_pat0(node_T arg1,int arg2);
gen_e OPos_pat0_con_clos(gen_e arg1);
struct ONeg_
{
int type;
stamp st;
int index;
node_T f0;
};
struct ONeg_decon
{
int index;
node_T f0;
};
struct NContraGroup_
{
int type;
stamp st;
node_T f0;
};
struct NContraGroup_decon
{
node_T f0;
};
node_T ONeg(int arg1,node_T arg2);
node_T NContraGroup(node_T arg1);
struct ONeg_decon ONeg_decon(node_T arg1);
struct NContraGroup_decon NContraGroup_decon(node_T arg1);
struct NContraGroupProj0_
{
int type;
stamp st;
node_T f0;
};
gen_e NContraGroup_pat0_con(gen_e arg1);
node_T NContraGroup_pat0(node_T arg1);
static int ONeg_index_0;
struct ONegProj0_
{
int type;
stamp st;
int index;
node_T f0;
};
gen_e ONeg_pat0_con(gen_e arg1,int arg2);
node_T ONeg_pat0(node_T arg1,int arg2);
gen_e ONeg_pat0_con_clos(gen_e arg1);
node_T Pos(node_T arg1);
struct Pos_decon Pos_decon(node_T arg1);
struct Pos_
{
int type;
stamp st;
node_T f0;
};
struct Pos_decon
{
node_T f0;
};
struct PosProj0_
{
int type;
stamp st;
node_T f0;
};
gen_e Pos_pat0_con(gen_e arg1);
node_T Pos_pat0(node_T arg1);
void node_T_print(FILE* arg1,node_T arg2);
bool node_T_res_proj(setif_var arg1,gen_e arg2);
void node_T_con_match(gen_e arg1,gen_e arg2);

stamp node_T_get_stamp(gen_e arg1) 
{
return setif_get_stamp((gen_e)arg1);
}

bool node_T_is_var(gen_e arg1) 
{
return setif_is_var((gen_e)arg1);
}

DEFINE_LIST(node_T_list,gen_e);
node_T node_T_zero(void)
{
 return setif_zero();
}

node_T node_T_one(void)
{
 return setif_one();
}

node_T node_T_wild(void)
{
 return setif_wild();
}

node_T node_T_fresh(const char *name)
{
 return setif_fresh(name);
}

node_T node_T_fresh_small(const char *name)
{
 return setif_fresh_small(name);
}

node_T node_T_fresh_large(const char *name)
{
 return setif_fresh_large(name);
}

node_T node_T_union(node_T_list exprs) 
{
 return setif_union(exprs);
}

node_T node_T_inter(node_T_list exprs) 
{
 return setif_inter(exprs);
}

node_T node_T_constant(const char *name) 
{
 return setif_constant(name);
}

bool node_T_eq(node_T e1, node_T e2) 
{
 return setif_eq(e1,e2);
}

int node_T_cmp(const node_T e1,const node_T e2) 
{
 return setif_get_stamp(e1) - setif_get_stamp(e2);
}

bool node_T_is_constant(node_T e, const char *name) 
{
 if (setif_is_constant(e))
if (!name) return TRUE;
else return (! strcmp(name,setif_get_constant_name(e)));
else return FALSE;
}

node_T_list node_T_tlb(node_T e) 
{
 return setif_tlb(e);
}

void node_T_inclusion_ind(node_T e1, node_T e2) 
{
 setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,e1,e2);
}

void node_T_inclusion(node_T e1, node_T e2) 
{
 banshee_clock_tick();
node_T_inclusion_ind(e1,e2);
}

void node_T_inclusion_ind_contra(node_T e1, node_T e2) 
{
 setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,e2,e1);
}

void node_T_unify_ind(node_T e1, node_T e2) 
{
 setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,e1,e2);
setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,e2,e1);
}
void node_T_unify(node_T e1, node_T e2) 
{
 banshee_clock_tick();
node_T_unify_ind(e1,e2);
}
 
bool node_T_is_OPos(node_T e, int index)
{
 return ((setif_term)e)->type == 11 && ((struct OPos_ *)e)->index == index;
}

node_T OPos(int arg1,node_T arg2) 
{
struct OPos_ *ret;
stamp s[3];
s[0] = OPOS_;
s[2] = arg1;
s[2] = node_T_get_stamp((gen_e)arg2);
if ((ret = (struct OPos_ *)term_hash_find(setif_hash,s,3)) == NULL)
{
ret = ralloc(permanent,struct OPos_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->index = arg1;
ret->f0 = arg2;
term_hash_insert(setif_hash,(gen_e)ret,s,3);
}
return (node_T)ret;
}

bool node_T_is_NGroup(node_T e)
{
 return ((setif_term)e)->type == 12;
}

node_T NGroup(node_T arg1) 
{
struct NGroup_ *ret;
stamp s[2];
s[0] = NGROUP_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct NGroup_ *)term_hash_find(setif_hash,s,2)) == NULL)
{
ret = ralloc(permanent,struct NGroup_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

struct OPos_decon OPos_decon(node_T arg1) 
{
if (((setif_term)arg1)->type == OPOS_)
{
struct OPos_* c = (struct OPos_ *)arg1;
return (struct OPos_decon){c->index,c->f0};

}
else 
return (struct OPos_decon){0,NULL};
}

struct NGroup_decon NGroup_decon(node_T arg1) 
{
if (((setif_term)arg1)->type == NGROUP_)
{
struct NGroup_* c = (struct NGroup_ *)arg1;
return (struct NGroup_decon){c->f0};

}
else 
return (struct NGroup_decon){NULL};
}

gen_e NGroup_pat0_con(gen_e arg1) 
{
return (gen_e)NGroup_pat0((node_T)arg1);
}

node_T NGroup_pat0(node_T arg1) 
{
struct NGroupProj0_* ret;
stamp s[2];
s[0] = NGROUPPROJ0_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct NGroupProj0_ *)term_hash_find(setif_hash,s,2)) == NULL) 
{
ret = ralloc(permanent,struct NGroupProj0_);
ret->type = NGROUPPROJ0_;
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

gen_e get_OPos_proj0_arg(gen_e_list arg1)
{
gen_e temp;
gen_e_list_scanner scan;
gen_e_list_scan(arg1,&scan);
while (gen_e_list_next(&scan,&temp))
{
if (((setif_term)temp)->type == OPOSPROJ0_ && ((struct OPosProj0_ *)temp)->index == OPos_index_0)
return (gen_e)((struct OPosProj0_ * ) temp)->f0;
} 
return NULL;
}

node_T OPos_proj0(node_T arg1, int index) 
 {
node_T c;
banshee_clock_tick();
OPos_index_0 = index;
if (setif_is_var(arg1))
{
setif_var v = (setif_var)arg1;
c = (node_T)sv_get_ub_proj(v,get_OPos_proj0_arg);
if (c != NULL)
return c;
else
{
node_T e;
gen_e lb; 
bounds_scanner scan; 
c = node_T_fresh(NULL);
e = OPos_pat0(c, index);
sv_add_ub_proj(v,e);
if (!banshee_check_rollback(setif_sort)) {
setif_register_rollback();
}
setif_register_ub_proj(sv_get_ub_projs(v),e);
bounds_scan(sv_get_lbs(v),&scan);
while (bounds_next(&scan,&lb))
{
setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,lb,e);
}
return c;
}
}
else if ( ((setif_term)arg1)->type == OPOS_ && ((struct OPos_ * )arg1)->index == index)
return ((struct OPos_ * )arg1)->f0;
else if ( setif_is_zero(arg1) || ((setif_term)arg1)->type == OPOS_)
return node_T_zero();
else if ( setif_is_union(arg1))
{
c = get_OPos_proj0_arg(setif_get_proj_cache(arg1));
if (c != NULL)
return c;
else
{
node_T e;
c = node_T_fresh(NULL);
e = OPos_pat0(c, index);
setif_set_proj_cache(arg1,e);
node_T_inclusion_ind(arg1,e);
return c;
}
}
else
{
node_T e;
c = node_T_fresh(NULL);
e = OPos_pat0(c,index);
node_T_inclusion_ind(arg1,e);
return c;
}
}

gen_e OPos_pat0_con(gen_e arg1,int arg2) 
{
return (gen_e)OPos_pat0((node_T)arg1, arg2);
}

node_T OPos_pat0(node_T arg1,int arg2) 
{
struct OPosProj0_* ret;
stamp s[3];
s[0] = OPOSPROJ0_;
s[1] = node_T_get_stamp((gen_e)arg1);
s[2] = arg2;
if ((ret = (struct OPosProj0_ *)term_hash_find(setif_hash,s,3)) == NULL) 
{
ret = ralloc(permanent,struct OPosProj0_);
ret->type = OPOSPROJ0_;
ret->st = stamp_fresh();
ret->f0 = arg1;
ret->index = arg2;
term_hash_insert(setif_hash,(gen_e)ret,s,3);
}
return (node_T)ret;
}

gen_e OPos_pat0_con_clos(gen_e arg1) 
{
return (gen_e)OPos_pat0((node_T)arg1,OPos_index_0);
}

bool node_T_is_ONeg(node_T e, int index)
{
 return ((setif_term)e)->type == 15 && ((struct ONeg_ *)e)->index == index;
}

node_T ONeg(int arg1,node_T arg2) 
{
struct ONeg_ *ret;
stamp s[3];
s[0] = ONEG_;
s[2] = arg1;
s[2] = node_T_get_stamp((gen_e)arg2);
if ((ret = (struct ONeg_ *)term_hash_find(setif_hash,s,3)) == NULL)
{
ret = ralloc(permanent,struct ONeg_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->index = arg1;
ret->f0 = arg2;
term_hash_insert(setif_hash,(gen_e)ret,s,3);
}
return (node_T)ret;
}

bool node_T_is_NContraGroup(node_T e)
{
 return ((setif_term)e)->type == 16;
}

node_T NContraGroup(node_T arg1) 
{
struct NContraGroup_ *ret;
stamp s[2];
s[0] = NCONTRAGROUP_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct NContraGroup_ *)term_hash_find(setif_hash,s,2)) == NULL)
{
ret = ralloc(permanent,struct NContraGroup_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

struct ONeg_decon ONeg_decon(node_T arg1) 
{
if (((setif_term)arg1)->type == ONEG_)
{
struct ONeg_* c = (struct ONeg_ *)arg1;
return (struct ONeg_decon){c->index,c->f0};

}
else 
return (struct ONeg_decon){0,NULL};
}

struct NContraGroup_decon NContraGroup_decon(node_T arg1) 
{
if (((setif_term)arg1)->type == NCONTRAGROUP_)
{
struct NContraGroup_* c = (struct NContraGroup_ *)arg1;
return (struct NContraGroup_decon){c->f0};

}
else 
return (struct NContraGroup_decon){NULL};
}

gen_e NContraGroup_pat0_con(gen_e arg1) 
{
return (gen_e)NContraGroup_pat0((node_T)arg1);
}

node_T NContraGroup_pat0(node_T arg1) 
{
struct NContraGroupProj0_* ret;
stamp s[2];
s[0] = NCONTRAGROUPPROJ0_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct NContraGroupProj0_ *)term_hash_find(setif_hash,s,2)) == NULL) 
{
ret = ralloc(permanent,struct NContraGroupProj0_);
ret->type = NCONTRAGROUPPROJ0_;
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

gen_e get_ONeg_proj0_arg(gen_e_list arg1)
{
gen_e temp;
gen_e_list_scanner scan;
gen_e_list_scan(arg1,&scan);
while (gen_e_list_next(&scan,&temp))
{
if (((setif_term)temp)->type == ONEGPROJ0_ && ((struct ONegProj0_ *)temp)->index == ONeg_index_0)
return (gen_e)((struct ONegProj0_ * ) temp)->f0;
} 
return NULL;
}

node_T ONeg_proj0(node_T arg1, int index) 
 {
node_T c;
banshee_clock_tick();
ONeg_index_0 = index;
if (setif_is_var(arg1))
{
setif_var v = (setif_var)arg1;
c = (node_T)sv_get_ub_proj(v,get_ONeg_proj0_arg);
if (c != NULL)
return c;
else
{
node_T e;
gen_e lb; 
bounds_scanner scan; 
c = node_T_fresh(NULL);
e = ONeg_pat0(c, index);
sv_add_ub_proj(v,e);
if (!banshee_check_rollback(setif_sort)) {
setif_register_rollback();
}
setif_register_ub_proj(sv_get_ub_projs(v),e);
bounds_scan(sv_get_lbs(v),&scan);
while (bounds_next(&scan,&lb))
{
setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,lb,e);
}
return c;
}
}
else if ( ((setif_term)arg1)->type == ONEG_ && ((struct ONeg_ * )arg1)->index == index)
return ((struct ONeg_ * )arg1)->f0;
else if ( setif_is_zero(arg1) || ((setif_term)arg1)->type == ONEG_)
return node_T_zero();
else if ( setif_is_union(arg1))
{
c = get_ONeg_proj0_arg(setif_get_proj_cache(arg1));
if (c != NULL)
return c;
else
{
node_T e;
c = node_T_fresh(NULL);
e = ONeg_pat0(c, index);
setif_set_proj_cache(arg1,e);
node_T_inclusion_ind(arg1,e);
return c;
}
}
else
{
node_T e;
c = node_T_fresh(NULL);
e = ONeg_pat0(c,index);
node_T_inclusion_ind(arg1,e);
return c;
}
}

gen_e ONeg_pat0_con(gen_e arg1,int arg2) 
{
return (gen_e)ONeg_pat0((node_T)arg1, arg2);
}

node_T ONeg_pat0(node_T arg1,int arg2) 
{
struct ONegProj0_* ret;
stamp s[3];
s[0] = ONEGPROJ0_;
s[1] = node_T_get_stamp((gen_e)arg1);
s[2] = arg2;
if ((ret = (struct ONegProj0_ *)term_hash_find(setif_hash,s,3)) == NULL) 
{
ret = ralloc(permanent,struct ONegProj0_);
ret->type = ONEGPROJ0_;
ret->st = stamp_fresh();
ret->f0 = arg1;
ret->index = arg2;
term_hash_insert(setif_hash,(gen_e)ret,s,3);
}
return (node_T)ret;
}

gen_e ONeg_pat0_con_clos(gen_e arg1) 
{
return (gen_e)ONeg_pat0((node_T)arg1,ONeg_index_0);
}

bool node_T_is_Pos(node_T e)
{
 return ((setif_term)e)->type == 19;
}

node_T Pos(node_T arg1) 
{
struct Pos_ *ret;
stamp s[2];
s[0] = POS_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct Pos_ *)term_hash_find(setif_hash,s,2)) == NULL)
{
ret = ralloc(permanent,struct Pos_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

struct Pos_decon Pos_decon(node_T arg1) 
{
if (((setif_term)arg1)->type == POS_)
{
struct Pos_* c = (struct Pos_ *)arg1;
return (struct Pos_decon){c->f0};

}
else 
return (struct Pos_decon){NULL};
}

gen_e get_Pos_proj0_arg(gen_e_list arg1)
{
gen_e temp;
gen_e_list_scanner scan;
gen_e_list_scan(arg1,&scan);
while (gen_e_list_next(&scan,&temp))
{
if (((setif_term)temp)->type == POSPROJ0_)
return (gen_e)((struct PosProj0_ * ) temp)->f0;
} 
return NULL;
}

node_T Pos_proj0(node_T arg1) 
 {
node_T c;
banshee_clock_tick();
if (setif_is_var(arg1))
{
setif_var v = (setif_var)arg1;
c = (node_T)sv_get_ub_proj(v,get_Pos_proj0_arg);
if (c != NULL)
return c;
else
{
node_T e;
gen_e lb; 
bounds_scanner scan; 
c = node_T_fresh(NULL);
e = Pos_pat0(c);
sv_add_ub_proj(v,e);
if (!banshee_check_rollback(setif_sort)) {
setif_register_rollback();
}
setif_register_ub_proj(sv_get_ub_projs(v),e);
bounds_scan(sv_get_lbs(v),&scan);
while (bounds_next(&scan,&lb))
{
setif_inclusion(node_T_con_match,node_T_res_proj,node_T_print,lb,e);
}
return c;
}
}
else if ( ((setif_term)arg1)->type == POS_)
return ((struct Pos_ * )arg1)->f0;
else if ( setif_is_zero(arg1))
return node_T_zero();
else if ( setif_is_union(arg1))
{
c = get_Pos_proj0_arg(setif_get_proj_cache(arg1));
if (c != NULL)
return c;
else
{
node_T e;
c = node_T_fresh(NULL);
e = Pos_pat0(c);
setif_set_proj_cache(arg1,e);
node_T_inclusion_ind(arg1,e);
return c;
}
}
else
{
node_T e;
c = node_T_fresh(NULL);
e = Pos_pat0(c);
node_T_inclusion_ind(arg1,e);
return c;
}
}

gen_e Pos_pat0_con(gen_e arg1) 
{
return (gen_e)Pos_pat0((node_T)arg1);
}

node_T Pos_pat0(node_T arg1) 
{
struct PosProj0_* ret;
stamp s[2];
s[0] = POSPROJ0_;
s[1] = node_T_get_stamp((gen_e)arg1);
if ((ret = (struct PosProj0_ *)term_hash_find(setif_hash,s,2)) == NULL) 
{
ret = ralloc(permanent,struct PosProj0_);
ret->type = POSPROJ0_;
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(setif_hash,(gen_e)ret,s,2);
}
return (node_T)ret;
}

void node_T_print(FILE* arg1,node_T arg2) 
{
switch(((setif_term)arg2)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s::%ld",sv_get_name((setif_var)arg2), (long) sv_get_stamp((setif_var)arg2));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1, "%s", setif_get_constant_name(arg2));
break;
case UNION_TYPE:
{
gen_e_list list = setif_get_union(arg2);
gen_e_list_scanner scan;
gen_e temp;
gen_e_list_scan(list,&scan);
if (gen_e_list_next(&scan,&temp))
node_T_print(arg1,temp);
while (gen_e_list_next(&scan,&temp))
{
fprintf(arg1," || ");
node_T_print(arg1,temp);
}

}
break;
case INTER_TYPE:
{
gen_e_list list = setif_get_inter(arg2);
gen_e_list_scanner scan;
gen_e temp;
gen_e_list_scan(list,&scan);
if (gen_e_list_next(&scan,&temp))
node_T_print(arg1,temp);
while (gen_e_list_next(&scan,&temp))
{
fprintf(arg1," && ");
node_T_print(arg1,temp);
}

}
break;
case OPOS_:
{
fprintf(arg1,"OPos(");
node_T_print(arg1,((struct OPos_ *)arg2)->f0);
fprintf(arg1,")");

}
break;
case ONEG_:
{
fprintf(arg1,"ONeg(");
node_T_print(arg1,((struct ONeg_ *)arg2)->f0);
fprintf(arg1,")");

}
break;
case POS_:
{
fprintf(arg1,"Pos(");
node_T_print(arg1,((struct Pos_ *)arg2)->f0);
fprintf(arg1,")");

}
break;
case OPOSPROJ0_:
{
fprintf(arg1,"Proj[OPos,0,");
node_T_print(arg1,((struct OPosProj0_ *)arg2)->f0);
fprintf(arg1,"]");

}
break;
case ONEGPROJ0_:
{
fprintf(arg1,"Proj[ONeg,0,");
node_T_print(arg1,((struct ONegProj0_ *)arg2)->f0);
fprintf(arg1,"]");

}
break;
case POSPROJ0_:
{
fprintf(arg1,"Proj[Pos,0,");
node_T_print(arg1,((struct PosProj0_ *)arg2)->f0);
fprintf(arg1,"]");

}
break;

default:
return ;
}

}

bool node_T_res_proj(setif_var arg1,gen_e arg2) 
{
switch(((setif_term)arg2)->type)
{
case OPOSPROJ0_:
{
OPos_index_0 = ((struct OPosProj0_ *)arg2)->index;
return setif_proj_merge(arg1,(gen_e)((struct OPosProj0_ *)arg2)->f0,get_OPos_proj0_arg,OPos_pat0_con_clos, (fresh_large_fn_ptr)node_T_fresh_large,(incl_fn_ptr)node_T_inclusion_ind,node_T_inclusion_ind);

}
break;
case ONEGPROJ0_:
{
ONeg_index_0 = ((struct ONegProj0_ *)arg2)->index;
return setif_proj_merge(arg1,(gen_e)((struct ONegProj0_ *)arg2)->f0,get_ONeg_proj0_arg,ONeg_pat0_con_clos, (fresh_large_fn_ptr)node_T_fresh_large,(incl_fn_ptr)node_T_inclusion_ind_contra,node_T_inclusion_ind);

}
break;
case POSPROJ0_:
return setif_proj_merge(arg1,(gen_e)((struct PosProj0_ *)arg2)->f0,get_Pos_proj0_arg,Pos_pat0_con, (fresh_large_fn_ptr)node_T_fresh_large,(incl_fn_ptr)node_T_inclusion_ind,node_T_inclusion_ind);
break;

default:
return FALSE;
}

return FALSE;
}

void node_T_con_match(gen_e arg1,gen_e arg2) 
{
switch(((setif_term)arg1)->type)
{
case OPOS_:
switch(((setif_term)arg2)->type)
{
case OPOS_:
if ((((struct OPos_ *)arg1)->index == ((struct OPos_ *)arg2)->index))
{
node_T_inclusion_ind(((struct OPos_ *)arg1)->f0,((struct OPos_ *)arg2)->f0);

}
else 
handle_error(arg1,arg2,bek_cons_mismatch);
break;
case OPOSPROJ0_:
if ((((struct OPos_ *)arg1)->index == ((struct OPosProj0_ *)arg2)->index))
node_T_inclusion_ind(((struct OPos_ *)arg1)->f0,((struct OPosProj0_ *)arg2)->f0);
else 
return ;
break;
case NGROUPPROJ0_:
node_T_inclusion_ind(((struct OPos_ *)arg1)->f0,((struct NGroupProj0_ *)arg2)->f0);
break;
case POSPROJ0_:
return ;
break;
case ONEGPROJ0_:
return ;
break;
case NCONTRAGROUPPROJ0_:
return ;
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;
case ONEG_:
switch(((setif_term)arg2)->type)
{
case ONEG_:
if ((((struct ONeg_ *)arg1)->index == ((struct ONeg_ *)arg2)->index))
{
node_T_inclusion_ind_contra(((struct ONeg_ *)arg1)->f0,((struct ONeg_ *)arg2)->f0);

}
else 
handle_error(arg1,arg2,bek_cons_mismatch);
break;
case ONEGPROJ0_:
if ((((struct ONeg_ *)arg1)->index == ((struct ONegProj0_ *)arg2)->index))
node_T_inclusion_ind_contra(((struct ONeg_ *)arg1)->f0,((struct ONegProj0_ *)arg2)->f0);
else 
return ;
break;
case NCONTRAGROUPPROJ0_:
node_T_inclusion_ind_contra(((struct ONeg_ *)arg1)->f0,((struct NContraGroupProj0_ *)arg2)->f0);
break;
case POSPROJ0_:
return ;
break;
case OPOSPROJ0_:
return ;
break;
case NGROUPPROJ0_:
return ;
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;
case POS_:
switch(((setif_term)arg2)->type)
{
case POS_:
{
node_T_inclusion_ind(((struct Pos_ *)arg1)->f0,((struct Pos_ *)arg2)->f0);

}
break;
case POSPROJ0_:
node_T_inclusion_ind(((struct Pos_ *)arg1)->f0,((struct PosProj0_ *)arg2)->f0);
break;
case ONEGPROJ0_:
return ;
break;
case NCONTRAGROUPPROJ0_:
return ;
break;
case OPOSPROJ0_:
return ;
break;
case NGROUPPROJ0_:
return ;
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;
case NGROUP_:
switch(((setif_term)arg2)->type)
{
case OPOS_:
{
node_T_inclusion_ind(((struct NGroup_ *)arg1)->f0,((struct OPos_ *)arg2)->f0);

}
break;
case NGROUPPROJ0_:
node_T_inclusion_ind(((struct NGroup_ *)arg1)->f0,((struct NGroupProj0_ *)arg2)->f0);
break;
case OPOSPROJ0_:
node_T_inclusion_ind(((struct NGroup_ *)arg1)->f0,((struct OPosProj0_ *)arg2)->f0);
break;
case POSPROJ0_:
return ;
break;
case ONEGPROJ0_:
return ;
break;
case NCONTRAGROUPPROJ0_:
return ;
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;
case NCONTRAGROUP_:
switch(((setif_term)arg2)->type)
{
case ONEG_:
{
node_T_inclusion_ind_contra(((struct NContraGroup_ *)arg1)->f0,((struct ONeg_ *)arg2)->f0);

}
break;
case NCONTRAGROUPPROJ0_:
node_T_inclusion_ind_contra(((struct NContraGroup_ *)arg1)->f0,((struct NContraGroupProj0_ *)arg2)->f0);
break;
case ONEGPROJ0_:
node_T_inclusion_ind_contra(((struct NContraGroup_ *)arg1)->f0,((struct ONegProj0_ *)arg2)->f0);
break;
case POSPROJ0_:
return ;
break;
case OPOSPROJ0_:
return ;
break;
case NGROUPPROJ0_:
return ;
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;

default:
return ;
}

return;
}

void dyckcfl_terms_init(void) 
{
engine_init();
setif_init();
}

void dyckcfl_terms_reset(void) 
{
engine_reset();
setif_reset();
}

void dyckcfl_terms_stats(FILE * arg1) 
{
engine_stats(arg1);
}

void dyckcfl_terms_print_graph(FILE * arg1) 
{
print_constraint_graphs(arg1);
}

void dyckcfl_terms_serialize(FILE * arg1,hash_table * arg2,unsigned long arg3) 
{
return;
}

hash_table * dyckcfl_terms_deserialize(FILE * arg1) 
{
return NULL;
}

void dyckcfl_terms_region_serialize(FILE * arg1) 
{
return;
}

void dyckcfl_terms_region_deserialize(translation arg1,FILE * arg2) 
{
return;
}

